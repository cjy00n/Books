# 함수 레벨 스코프

- 지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했다.
- 이는 **코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다**는 의미이다.
- C나 Java 등을 비롯한 대부분의 프로그래밍 언어는 함수 몸체만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든다.
- 이러한 특성을 `**블록 레벨 스코프(block level scope)**`라 한다.
- 하지만 **`var`키워드로 선언된 변수는 오로지 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인정한다.**
- 이러한 특성을 **`함수 레벨 스코프`**라 한다.

```js
// 예제 13-07

var x = 1;

if (true) {
  // var 키워드로 선언된 변수는 함수의 코드 블록(함수 몸체)만을 지역 스코프로 인전한다.
  // 함수 밖에서 var 키워드로 선언된 변수는 코드 블록 내에서 선언되었다 할지라도 모두 전역 변수다.
  // 따라서 x는 전역변수다. 이미 선언된 전역 변수 x가 있으므로 x 변수는 중복 선언된다.
  // 이는 의도치 않게 변수 값이 변경되는 부작용을 발생시킨다.
  var x = 10;
}

console.log(x); // 10
```

- 위에서 전역 변수 x는 중복 선언되고 그 결과 의도치 않은 전역 변수의 값이 재할당된다.

```js
// 예제 13-08

var i = 10;

// for 문에서 선언한 i는 전역 변수다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.

for (var i = 0; i < 5; i++) {
  console.log(i); // 0 1 2 3 4
}

// 의도치 않게 변수의 값이 변경되었다.
console.log(i); // 5
```

- var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정하지만 ES6에서 도입된 let, const 키워드는 블록 레벨 스코프를 지원한다.

# 렉시컬 스코프

```js
// 예제 13-09

var x = 1;

function foo() {
  var x = 10;
  bar();
}

function bar() {
  console.log(x);
}

foo(); // 1
bar(); // 1
```

- 위 예제의 실행 결과는 bar 함수의 상위 스코프가 무엇인지에 따라 결정된다.
- 두 가지 패턴을 예측할 수 있다.

1. 함수를 어디서 호출했는지에 따라 함수의 상위 스코프를 결정한다. ⇒ `동적 스코프`
2. 함수를 어디서 정의했는지에 따라 함수의 상위 스코프를 결정한다. ⇒ `렉시컬 스코프`or `정적 스코프`

- 첫번째 방식으로 함수의 상위 스코프를 결정한다면 bar 함수의 상위 스코프는 foo 함수의 지역 스코프와 전역 스코프일 것이다.
- 두번째 방식으로 함수의 상위 스코프를 결정한다면 bar 함수의 상위 스코프는 전역 스코프일 것이다.
- 프로그래밍 언어는 일반적으로 이 두 가지 방식 중 한가지 방식으로 함수의 상위 스코프를 결정한다.

### 동적 스코프

- 첫번째 방식을 동적 스코프라고 한다.
- 함수를 정의하는 시점에는 함수가 어디서 호출될지 알 수 없다.
- 따라서 함수가 호출되는 시점에 동적으로 상위 스코프를 결정해야 하기 때문에 동적 스코프라고 부른다.

### 렉시컬 스코프(정적 스코프)

- 두번째 방식을 렉시컬 스코프 또는 정적 스코프라고 한다.
- 동적 스코프 방식처럼 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 때문에 정적 스코프라고 부른다.
- 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다.

- 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 **함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.**
- **함수가 호출된 위치는 상위 스코프 결정에 어떠한 영향도 주지 않는다.**
- 즉, **함수의 상위 스코프는 언제나 자신이 정의된 스코프이다.**

- 함수의 상위 스코프는 함수 정의가 실행될 때 정적으로 결정된다.
- 함수 정의(함수 선언문 또는 함수 표현식)가 실행되어 생성된 함수 객체는 이렇게 결정된 상위 스코프를 기억한다.
- 함수가 호출될 때마다 함수의 상위 스코프를 참조할 필요가 있기 때문이다.
- 렉시컬 스코프는 클로저와 깊은 관계가 있다.
